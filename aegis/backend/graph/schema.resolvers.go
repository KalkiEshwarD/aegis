package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.79

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"strconv"
	"strings"

	"github.com/balkanid/aegis-backend/graph/generated"
	"github.com/balkanid/aegis-backend/graph/model"
	"github.com/balkanid/aegis-backend/internal/middleware"
	"github.com/balkanid/aegis-backend/internal/models"
	"github.com/balkanid/aegis-backend/internal/services"
)

// ID is the resolver for the id field.
func (r *fileResolver) ID(ctx context.Context, obj *models.File) (string, error) {
	return fmt.Sprintf("%d", obj.ID), nil
}

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, input model.RegisterInput) (*model.AuthPayload, error) {
	userService := r.Resolver.UserService

	user, token, err := userService.Register(input.Email, input.Password)
	if err != nil {
		return nil, err
	}

	return &model.AuthPayload{
		Token: token,
		User:  user,
	}, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (*model.AuthPayload, error) {
	userService := r.Resolver.UserService

	user, token, err := userService.Login(input.Email, input.Password)
	if err != nil {
		return nil, err
	}

	return &model.AuthPayload{
		Token: token,
		User:  user,
	}, nil
}

// UploadFile is the resolver for the uploadFile field.
func (r *mutationResolver) UploadFile(ctx context.Context, input model.UploadFileInput) (*models.UserFile, error) {
	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthenticated: %w", err)
	}

	sizeBytes := int64(input.SizeBytes)

	// Check storage quota
	err = r.Resolver.UserService.CheckStorageQuota(user.ID, sizeBytes)
	if err != nil {
		return nil, err
	}

	// For now, create a simple reader from the upload data
	// In production, this would handle the actual file upload
	var fileReader io.Reader
	if input.FileData.File != nil {
		fileReader = input.FileData.File
	} else {
		// Fallback for test scenarios - create content based on size_bytes
		content := fmt.Sprintf("test file content of size %d bytes", sizeBytes)
		if len(content) > int(sizeBytes) {
			content = content[:sizeBytes]
		}
		fileReader = strings.NewReader(content)
	}

	// Upload file
	userFile, err := r.Resolver.FileService.UploadFile(
		user.ID,
		input.Filename,
		input.MimeType,
		input.ContentHash,
		input.EncryptedKey,
		fileReader,
		sizeBytes,
	)
	if err != nil {
		return nil, err
	}

	// Update user's storage usage
	err = r.Resolver.UserService.UpdateStorageUsage(user.ID, sizeBytes)
	if err != nil {
		return nil, err
	}

	return userFile, nil
}

// UploadFileFromMap is the resolver for the uploadFileFromMap field.
// This solves the "map[string]interface {} is not an Upload" error using JSON unmarshaling
func (r *mutationResolver) UploadFileFromMap(ctx context.Context, input model.UploadFileFromMapInput) (*models.UserFile, error) {
	// Add debug logging
	fmt.Printf("DEBUG: UploadFileFromMap called with input: %+v\n", input)
	fmt.Printf("DEBUG: Input data length: %d characters\n", len(input.Data))

	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthenticated: %w", err)
	}

	// Parse the JSON string into a map
	var uploadData map[string]interface{}
	err = json.Unmarshal([]byte(input.Data), &uploadData)
	if err != nil {
		return nil, fmt.Errorf("failed to parse upload data JSON: %w", err)
	}

	// Get map keys for logging
	var keys []string
	for k := range uploadData {
		keys = append(keys, k)
	}
	fmt.Printf("DEBUG: Parsed upload data keys: %v\n", keys)

	// Log file data size if present
	if fileData, ok := uploadData["file_data"].(string); ok {
		fmt.Printf("DEBUG: File data base64 length: %d characters\n", len(fileData))
	}

	// Check storage quota - extract size from the map
	sizeBytes := int64(0)
	if size, ok := uploadData["size_bytes"].(float64); ok {
		sizeBytes = int64(size)
	}

	err = r.Resolver.UserService.CheckStorageQuota(user.ID, sizeBytes)
	if err != nil {
		return nil, err
	}

	// Upload file using the new method that handles map conversion
	userFile, err := r.Resolver.FileService.UploadFileFromMap(user.ID, uploadData)
	if err != nil {
		return nil, err
	}

	// Update user's storage usage
	err = r.Resolver.UserService.UpdateStorageUsage(user.ID, sizeBytes)
	if err != nil {
		return nil, err
	}

	return userFile, nil
}

// DeleteFile is the resolver for the deleteFile field.
func (r *mutationResolver) DeleteFile(ctx context.Context, id string) (bool, error) {
	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return false, fmt.Errorf("unauthenticated: %w", err)
	}

	userFileID, err := strconv.ParseUint(id, 10, 32)
	if err != nil {
		return false, fmt.Errorf("invalid file ID: %w", err)
	}

	err = r.Resolver.FileService.DeleteFile(user.ID, uint(userFileID))
	if err != nil {
		return false, err
	}

	// Update storage usage (negative delta for deletion)
	err = r.Resolver.UserService.UpdateStorageUsage(user.ID, -int64(0)) // TODO: Get actual file size
	if err != nil {
		return false, err
	}

	return true, nil
}

// DownloadFile is the resolver for the downloadFile field.
func (r *mutationResolver) DownloadFile(ctx context.Context, id string) (string, error) {
	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return "", fmt.Errorf("unauthenticated: %w", err)
	}

	userFileID, err := strconv.ParseUint(id, 10, 32)
	if err != nil {
		return "", fmt.Errorf("invalid file ID: %w", err)
	}

	return r.Resolver.FileService.GetFileDownloadURL(user.ID, uint(userFileID))
}

// CreateRoom is the resolver for the createRoom field.
func (r *mutationResolver) CreateRoom(ctx context.Context, input model.CreateRoomInput) (*models.Room, error) {
	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthenticated: %w", err)
	}

	return r.Resolver.RoomService.CreateRoom(user.ID, input.Name)
}

// AddRoomMember is the resolver for the addRoomMember field.
func (r *mutationResolver) AddRoomMember(ctx context.Context, input model.AddRoomMemberInput) (bool, error) {
	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return false, fmt.Errorf("unauthenticated: %w", err)
	}

	roomID, err := strconv.ParseUint(input.RoomID, 10, 32)
	if err != nil {
		return false, fmt.Errorf("invalid room ID: %w", err)
	}

	userID, err := strconv.ParseUint(input.UserID, 10, 32)
	if err != nil {
		return false, fmt.Errorf("invalid user ID: %w", err)
	}

	var role models.RoomRole
	switch input.Role {
	case models.RoomRoleAdmin:
		role = models.RoomRoleAdmin
	case models.RoomRoleContentCreator:
		role = models.RoomRoleContentCreator
	case models.RoomRoleContentEditor:
		role = models.RoomRoleContentEditor
	case models.RoomRoleContentViewer:
		role = models.RoomRoleContentViewer
	default:
		return false, fmt.Errorf("invalid role: %s", input.Role)
	}

	err = r.Resolver.RoomService.AddRoomMember(uint(roomID), uint(userID), user.ID, role)
	if err != nil {
		return false, err
	}

	return true, nil
}

// RemoveRoomMember is the resolver for the removeRoomMember field.
func (r *mutationResolver) RemoveRoomMember(ctx context.Context, roomID string, userID string) (bool, error) {
	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return false, fmt.Errorf("unauthenticated: %w", err)
	}

	rID, err := strconv.ParseUint(roomID, 10, 32)
	if err != nil {
		return false, fmt.Errorf("invalid room ID: %w", err)
	}

	uID, err := strconv.ParseUint(userID, 10, 32)
	if err != nil {
		return false, fmt.Errorf("invalid user ID: %w", err)
	}

	err = r.Resolver.RoomService.RemoveRoomMember(uint(rID), uint(uID), user.ID)
	if err != nil {
		return false, err
	}

	return true, nil
}

// ShareFileToRoom is the resolver for the shareFileToRoom field.
func (r *mutationResolver) ShareFileToRoom(ctx context.Context, userFileID string, roomID string) (bool, error) {
	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return false, fmt.Errorf("unauthenticated: %w", err)
	}

	ufID, err := strconv.ParseUint(userFileID, 10, 32)
	if err != nil {
		return false, fmt.Errorf("invalid user file ID: %w", err)
	}

	rID, err := strconv.ParseUint(roomID, 10, 32)
	if err != nil {
		return false, fmt.Errorf("invalid room ID: %w", err)
	}

	err = r.Resolver.RoomService.ShareFileToRoom(uint(ufID), uint(rID), user.ID)
	if err != nil {
		return false, err
	}

	return true, nil
}

// RemoveFileFromRoom is the resolver for the removeFileFromRoom field.
func (r *mutationResolver) RemoveFileFromRoom(ctx context.Context, userFileID string, roomID string) (bool, error) {
	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return false, fmt.Errorf("unauthenticated: %w", err)
	}

	ufID, err := strconv.ParseUint(userFileID, 10, 32)
	if err != nil {
		return false, fmt.Errorf("invalid user file ID: %w", err)
	}

	rID, err := strconv.ParseUint(roomID, 10, 32)
	if err != nil {
		return false, fmt.Errorf("invalid room ID: %w", err)
	}

	err = r.Resolver.RoomService.RemoveFileFromRoom(uint(ufID), uint(rID), user.ID)
	if err != nil {
		return false, err
	}

	return true, nil
}

// PromoteUserToAdmin is the resolver for the promoteUserToAdmin field.
func (r *mutationResolver) PromoteUserToAdmin(ctx context.Context, userID string) (bool, error) {
	_, err := middleware.RequireAdmin(ctx)
	if err != nil {
		return false, fmt.Errorf("admin access required: %w", err)
	}

	uID, err := strconv.ParseUint(userID, 10, 32)
	if err != nil {
		return false, fmt.Errorf("invalid user ID: %w", err)
	}

	err = r.Resolver.UserService.PromoteToAdmin(uint(uID))
	if err != nil {
		return false, err
	}

	return true, nil
}

// DeleteUserAccount is the resolver for the deleteUserAccount field.
func (r *mutationResolver) DeleteUserAccount(ctx context.Context, userID string) (bool, error) {
	_, err := middleware.RequireAdmin(ctx)
	if err != nil {
		return false, fmt.Errorf("admin access required: %w", err)
	}

	uID, err := strconv.ParseUint(userID, 10, 32)
	if err != nil {
		return false, fmt.Errorf("invalid user ID: %w", err)
	}

	err = r.Resolver.UserService.DeleteUser(uint(uID))
	if err != nil {
		return false, err
	}

	return true, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*models.User, error) {
	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthenticated: %w", err)
	}
	return user, nil
}

// MyFiles is the resolver for the myFiles field.
func (r *queryResolver) MyFiles(ctx context.Context, filter *model.FileFilterInput) ([]*models.UserFile, error) {
	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthenticated: %w", err)
	}

	var fileFilter *services.FileFilter
	if filter != nil {
		fileFilter = &services.FileFilter{
			Filename: filter.Filename,
			MimeType: filter.MimeType,
		}
		if filter.MinSize != nil {
			minSize := int64(*filter.MinSize)
			fileFilter.MinSize = &minSize
		}
		if filter.MaxSize != nil {
			maxSize := int64(*filter.MaxSize)
			fileFilter.MaxSize = &maxSize
		}
		if filter.DateFrom != nil {
			dateFrom := interface{}(*filter.DateFrom)
			fileFilter.DateFrom = &dateFrom
		}
		if filter.DateTo != nil {
			dateTo := interface{}(*filter.DateTo)
			fileFilter.DateTo = &dateTo
		}
	}

	return r.Resolver.FileService.GetUserFiles(user.ID, fileFilter)
}

// MyStats is the resolver for the myStats field.
func (r *queryResolver) MyStats(ctx context.Context) (*model.UserStats, error) {
	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthenticated: %w", err)
	}

	stats, err := r.Resolver.UserService.GetUserStats(user.ID)
	if err != nil {
		return nil, err
	}

	return &model.UserStats{
		TotalFiles:     stats.TotalFiles,
		UsedStorage:    stats.UsedStorage,
		StorageQuota:   stats.StorageQuota,
		StorageSavings: stats.StorageSavings,
	}, nil
}

// MyRooms is the resolver for the myRooms field.
func (r *queryResolver) MyRooms(ctx context.Context) ([]*models.Room, error) {
	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthenticated: %w", err)
	}

	return r.Resolver.RoomService.GetUserRooms(user.ID)
}

// Room is the resolver for the room field.
func (r *queryResolver) Room(ctx context.Context, id string) (*models.Room, error) {
	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthenticated: %w", err)
	}

	roomID, err := strconv.ParseUint(id, 10, 32)
	if err != nil {
		return nil, fmt.Errorf("invalid room ID: %w", err)
	}

	return r.Resolver.RoomService.GetRoom(uint(roomID), user.ID)
}

// AdminDashboard is the resolver for the adminDashboard field.
func (r *queryResolver) AdminDashboard(ctx context.Context) (*model.AdminDashboard, error) {
	_, err := middleware.RequireAdmin(ctx)
	if err != nil {
		return nil, fmt.Errorf("admin access required: %w", err)
	}

	dashboard, err := r.Resolver.AdminService.GetDashboardStats()
	if err != nil {
		return nil, err
	}

	return &model.AdminDashboard{
		TotalUsers:       dashboard.TotalUsers,
		TotalFiles:       dashboard.TotalFiles,
		TotalStorageUsed: dashboard.TotalStorageUsed,
		RecentUploads:    dashboard.RecentUploads,
	}, nil
}

// AllUsers is the resolver for the allUsers field.
func (r *queryResolver) AllUsers(ctx context.Context) ([]*models.User, error) {
	_, err := middleware.RequireAdmin(ctx)
	if err != nil {
		return nil, fmt.Errorf("admin access required: %w", err)
	}

	return r.Resolver.UserService.GetAllUsers()
}

// AllFiles is the resolver for the allFiles field.
func (r *queryResolver) AllFiles(ctx context.Context) ([]*models.UserFile, error) {
	_, err := middleware.RequireAdmin(ctx)
	if err != nil {
		return nil, fmt.Errorf("admin access required: %w", err)
	}

	return r.Resolver.FileService.GetAllFiles()
}

// Health is the resolver for the health field.
func (r *queryResolver) Health(ctx context.Context) (string, error) {
	return "OK", nil
}

// ID is the resolver for the id field.
func (r *roomResolver) ID(ctx context.Context, obj *models.Room) (string, error) {
	return fmt.Sprintf("%d", obj.ID), nil
}

// CreatorID is the resolver for the creator_id field.
func (r *roomResolver) CreatorID(ctx context.Context, obj *models.Room) (string, error) {
	return fmt.Sprintf("%d", obj.CreatorID), nil
}

// ID is the resolver for the id field.
func (r *roomMemberResolver) ID(ctx context.Context, obj *models.RoomMember) (string, error) {
	return fmt.Sprintf("%d", obj.ID), nil
}

// RoomID is the resolver for the room_id field.
func (r *roomMemberResolver) RoomID(ctx context.Context, obj *models.RoomMember) (string, error) {
	return fmt.Sprintf("%d", obj.RoomID), nil
}

// UserID is the resolver for the user_id field.
func (r *roomMemberResolver) UserID(ctx context.Context, obj *models.RoomMember) (string, error) {
	return fmt.Sprintf("%d", obj.UserID), nil
}

// ID is the resolver for the id field.
func (r *userResolver) ID(ctx context.Context, obj *models.User) (string, error) {
	return fmt.Sprintf("%d", obj.ID), nil
}

// ID is the resolver for the id field.
func (r *userFileResolver) ID(ctx context.Context, obj *models.UserFile) (string, error) {
	return fmt.Sprintf("%d", obj.ID), nil
}

// UserID is the resolver for the user_id field.
func (r *userFileResolver) UserID(ctx context.Context, obj *models.UserFile) (string, error) {
	return fmt.Sprintf("%d", obj.UserID), nil
}

// FileID is the resolver for the file_id field.
func (r *userFileResolver) FileID(ctx context.Context, obj *models.UserFile) (string, error) {
	return fmt.Sprintf("%d", obj.FileID), nil
}

// EncryptionKey is the resolver for the encryption_key field.
func (r *userFileResolver) EncryptionKey(ctx context.Context, obj *models.UserFile) (string, error) {
	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return "", fmt.Errorf("unauthenticated: %w", err)
	}

	// Ensure the user owns this file
	if user.ID != obj.UserID {
		return "", fmt.Errorf("access denied: file does not belong to user")
	}

	return obj.EncryptionKey, nil
}

// File returns generated.FileResolver implementation.
func (r *Resolver) File() generated.FileResolver { return &fileResolver{r} }

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

// Room returns generated.RoomResolver implementation.
func (r *Resolver) Room() generated.RoomResolver { return &roomResolver{r} }

// RoomMember returns generated.RoomMemberResolver implementation.
func (r *Resolver) RoomMember() generated.RoomMemberResolver { return &roomMemberResolver{r} }

// User returns generated.UserResolver implementation.
func (r *Resolver) User() generated.UserResolver { return &userResolver{r} }

// UserFile returns generated.UserFileResolver implementation.
func (r *Resolver) UserFile() generated.UserFileResolver { return &userFileResolver{r} }

type fileResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type roomResolver struct{ *Resolver }
type roomMemberResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
type userFileResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//  - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//    it when you're done.
//  - You have helper methods in this file. Move them out to keep these resolver files clean.
/*
	func (r *roomResolver) Members(ctx context.Context, obj *models.Room) ([]*models.RoomMember, error) {
	return obj.Members, nil
}
func (r *roomResolver) Files(ctx context.Context, obj *models.Room) ([]*models.UserFile, error) {
	return obj.Files, nil
}
*/
