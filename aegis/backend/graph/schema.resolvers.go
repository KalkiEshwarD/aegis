package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.79

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"log"
	"strconv"
	"strings"

	"github.com/balkanid/aegis-backend/graph/generated"
	"github.com/balkanid/aegis-backend/graph/model"
	"github.com/balkanid/aegis-backend/internal/database"
	"github.com/balkanid/aegis-backend/internal/middleware"
	"github.com/balkanid/aegis-backend/internal/models"
	"github.com/balkanid/aegis-backend/internal/services"
	"github.com/gin-gonic/gin"
	"gorm.io/gorm"
)

// ID is the resolver for the id field.
func (r *fileResolver) ID(ctx context.Context, obj *models.File) (string, error) {
	return fmt.Sprintf("%d", obj.ID), nil
}

// ID is the resolver for the id field.
func (r *folderResolver) ID(ctx context.Context, obj *models.Folder) (string, error) {
	return fmt.Sprintf("%d", obj.ID), nil
}

// UserID is the resolver for the user_id field.
func (r *folderResolver) UserID(ctx context.Context, obj *models.Folder) (string, error) {
	return fmt.Sprintf("%d", obj.UserID), nil
}

// ParentID is the resolver for the parent_id field.
func (r *folderResolver) ParentID(ctx context.Context, obj *models.Folder) (*string, error) {
	if obj.ParentID == nil {
		return nil, nil
	}
	parentID := fmt.Sprintf("%d", *obj.ParentID)
	return &parentID, nil
}

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, input model.RegisterInput) (*model.AuthPayload, error) {
	userService := r.Resolver.UserService

	user, token, err := userService.Register(input.Username, input.Email, input.Password)
	if err != nil {
		return nil, err
	}

	// Set HttpOnly cookie for secure token storage
	ginCtx := ctx.Value("gin").(*gin.Context)
	ginCtx.SetCookie("aegis_token", token, 3600*24*30, "/", "", false, true) // 30 days, HttpOnly

	return &model.AuthPayload{
		Token: token, // Keep for backward compatibility, but frontend should ignore
		User:  user,
	}, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (*model.AuthPayload, error) {
	// For debugging: let's add some debug logging
	fmt.Printf("DEBUG: Login resolver called with identifier: %s\n", input.Identifier)

	userService := r.Resolver.UserService
	if userService == nil {
		return nil, fmt.Errorf("user service is nil")
	}

	user, token, err := userService.Login(input.Identifier, input.Password)
	if err != nil {
		fmt.Printf("DEBUG: User service login failed: %v\n", err)
		return nil, err
	}

	fmt.Printf("DEBUG: Login successful for user: %s\n", user.Email)

	// Set HttpOnly cookie for authentication
	ginCtx := ctx.Value("gin").(*gin.Context)
	ginCtx.SetCookie("aegis_token", token, 86400, "/", "", false, true) // 24 hours, HttpOnly

	return &model.AuthPayload{
		Token: token,
		User:  user,
	}, nil
}

// RefreshToken is the resolver for the refreshToken field.
func (r *mutationResolver) RefreshToken(ctx context.Context) (*model.AuthPayload, error) {
	panic(fmt.Errorf("not implemented: RefreshToken - refreshToken"))
}

// Logout is the resolver for the logout field.
func (r *mutationResolver) Logout(ctx context.Context) (bool, error) {
	// Clear the HttpOnly cookie
	ginCtx := ctx.Value("gin").(*gin.Context)
	ginCtx.SetCookie("aegis_token", "", -1, "/", "", false, true) // Expire immediately

	return true, nil
}

// UploadFile is the resolver for the uploadFile field.
func (r *mutationResolver) UploadFile(ctx context.Context, input model.UploadFileInput) (*models.UserFile, error) {
	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthenticated: %w", err)
	}

	sizeBytes := int64(input.SizeBytes)

	// Check storage quota
	err = r.Resolver.UserService.CheckStorageQuota(user.ID, sizeBytes)
	if err != nil {
		return nil, err
	}

	// For now, create a simple reader from the upload data
	// In production, this would handle the actual file upload
	var fileReader io.Reader
	if input.FileData.File != nil {
		fileReader = input.FileData.File
	} else {
		// Fallback for test scenarios - create content based on size_bytes
		content := fmt.Sprintf("test file content of size %d bytes", sizeBytes)
		if len(content) > int(sizeBytes) {
			content = content[:sizeBytes]
		}
		fileReader = strings.NewReader(content)
	}

	// Convert folder_id if provided
	var folderID *uint
	if input.FolderID != nil {
		fid, err := strconv.ParseUint(*input.FolderID, 10, 32)
		if err != nil {
			return nil, fmt.Errorf("invalid folder ID: %w", err)
		}
		fidUint := uint(fid)
		folderID = &fidUint
	}

	// Upload file
	userFile, err := r.Resolver.StorageService.UploadFile(
		user.ID,
		input.Filename,
		input.MimeType,
		input.ContentHash,
		input.EncryptedKey,
		fileReader,
		sizeBytes,
		folderID,
	)
	if err != nil {
		return nil, err
	}

	return userFile, nil
}

// UploadFileFromMap is the resolver for the uploadFileFromMap field.
// This solves the "map[string]interface {} is not an Upload" error using JSON unmarshaling
func (r *mutationResolver) UploadFileFromMap(ctx context.Context, input model.UploadFileFromMapInput) (*models.UserFile, error) {
	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthenticated: %w", err)
	}

	// Parse the JSON string into a map
	var uploadData map[string]interface{}
	err = json.Unmarshal([]byte(input.Data), &uploadData)
	if err != nil {
		return nil, fmt.Errorf("failed to parse upload data JSON: %w", err)
	}

	// Check storage quota - extract size from the map
	sizeBytes := int64(0)
	if size, ok := uploadData["size_bytes"].(float64); ok {
		sizeBytes = int64(size)
	}

	err = r.Resolver.UserService.CheckStorageQuota(user.ID, sizeBytes)
	if err != nil {
		return nil, err
	}

	// Upload file using the new method that handles map conversion
	userFile, err := r.Resolver.StorageService.UploadFileFromMap(user.ID, uploadData)
	if err != nil {
		return nil, err
	}

	return userFile, nil
}

// DeleteFile is the resolver for the deleteFile field.
func (r *mutationResolver) DeleteFile(ctx context.Context, id string) (bool, error) {
	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return false, fmt.Errorf("unauthenticated: %w", err)
	}

	userFileID, err := strconv.ParseUint(id, 10, 32)
	if err != nil {
		return false, fmt.Errorf("invalid file ID: %w", err)
	}

	err = r.Resolver.StorageService.DeleteFile(user.ID, uint(userFileID))
	if err != nil {
		return false, err
	}

	return true, nil
}

// RestoreFile is the resolver for the restoreFile field.
func (r *mutationResolver) RestoreFile(ctx context.Context, fileID string) (bool, error) {
	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return false, fmt.Errorf("unauthenticated: %w", err)
	}

	userFileID, err := strconv.ParseUint(fileID, 10, 32)
	if err != nil {
		return false, fmt.Errorf("invalid file ID: %w", err)
	}

	err = r.Resolver.StorageService.RestoreFile(user.ID, uint(userFileID))
	if err != nil {
		return false, err
	}

	return true, nil
}

// PermanentlyDeleteFile is the resolver for the permanentlyDeleteFile field.
func (r *mutationResolver) PermanentlyDeleteFile(ctx context.Context, fileID string) (bool, error) {
	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return false, fmt.Errorf("unauthenticated: %w", err)
	}

	userFileID, err := strconv.ParseUint(fileID, 10, 32)
	if err != nil {
		return false, fmt.Errorf("invalid file ID: %w", err)
	}

	err = r.Resolver.StorageService.PermanentlyDeleteFile(user.ID, uint(userFileID))
	if err != nil {
		return false, err
	}

	return true, nil
}

// DownloadFile is the resolver for the downloadFile field.
func (r *mutationResolver) DownloadFile(ctx context.Context, id string) (string, error) {
	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return "", fmt.Errorf("unauthenticated: %w", err)
	}

	userFileID, err := strconv.ParseUint(id, 10, 32)
	if err != nil {
		return "", fmt.Errorf("invalid file ID: %w", err)
	}

	return r.Resolver.StorageService.GetFileDownloadURL(ctx, user, uint(userFileID))
}

// CreateRoom is the resolver for the createRoom field.
func (r *mutationResolver) CreateRoom(ctx context.Context, input model.CreateRoomInput) (*models.Room, error) {
	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthenticated: %w", err)
	}

	return r.Resolver.RoomService.CreateRoom(user.ID, input.Name)
}

// AddRoomMember is the resolver for the addRoomMember field.
func (r *mutationResolver) AddRoomMember(ctx context.Context, input model.AddRoomMemberInput) (bool, error) {
	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return false, fmt.Errorf("unauthenticated: %w", err)
	}

	roomID, err := strconv.ParseUint(input.RoomID, 10, 32)
	if err != nil {
		return false, fmt.Errorf("invalid room ID: %w", err)
	}

	userID, err := strconv.ParseUint(input.UserID, 10, 32)
	if err != nil {
		return false, fmt.Errorf("invalid user ID: %w", err)
	}

	var role models.RoomRole
	switch input.Role {
	case models.RoomRoleAdmin:
		role = models.RoomRoleAdmin
	case models.RoomRoleContentCreator:
		role = models.RoomRoleContentCreator
	case models.RoomRoleContentEditor:
		role = models.RoomRoleContentEditor
	case models.RoomRoleContentViewer:
		role = models.RoomRoleContentViewer
	default:
		return false, fmt.Errorf("invalid role: %s", input.Role)
	}

	err = r.Resolver.RoomService.AddRoomMember(uint(roomID), uint(userID), user.ID, role)
	if err != nil {
		return false, err
	}

	return true, nil
}

// RemoveRoomMember is the resolver for the removeRoomMember field.
func (r *mutationResolver) RemoveRoomMember(ctx context.Context, roomID string, userID string) (bool, error) {
	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return false, fmt.Errorf("unauthenticated: %w", err)
	}

	rID, err := strconv.ParseUint(roomID, 10, 32)
	if err != nil {
		return false, fmt.Errorf("invalid room ID: %w", err)
	}

	uID, err := strconv.ParseUint(userID, 10, 32)
	if err != nil {
		return false, fmt.Errorf("invalid user ID: %w", err)
	}

	err = r.Resolver.RoomService.RemoveRoomMember(uint(rID), uint(uID), user.ID)
	if err != nil {
		return false, err
	}

	return true, nil
}

// ShareFileToRoom is the resolver for the shareFileToRoom field.
func (r *mutationResolver) ShareFileToRoom(ctx context.Context, userFileID string, roomID string) (bool, error) {
	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return false, fmt.Errorf("unauthenticated: %w", err)
	}

	ufID, err := strconv.ParseUint(userFileID, 10, 32)
	if err != nil {
		return false, fmt.Errorf("invalid user file ID: %w", err)
	}

	rID, err := strconv.ParseUint(roomID, 10, 32)
	if err != nil {
		return false, fmt.Errorf("invalid room ID: %w", err)
	}

	err = r.Resolver.RoomService.ShareFileToRoom(uint(ufID), uint(rID), user.ID)
	if err != nil {
		return false, err
	}

	return true, nil
}

// RemoveFileFromRoom is the resolver for the removeFileFromRoom field.
func (r *mutationResolver) RemoveFileFromRoom(ctx context.Context, userFileID string, roomID string) (bool, error) {
	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return false, fmt.Errorf("unauthenticated: %w", err)
	}

	ufID, err := strconv.ParseUint(userFileID, 10, 32)
	if err != nil {
		return false, fmt.Errorf("invalid user file ID: %w", err)
	}

	rID, err := strconv.ParseUint(roomID, 10, 32)
	if err != nil {
		return false, fmt.Errorf("invalid room ID: %w", err)
	}

	err = r.Resolver.RoomService.RemoveFileFromRoom(uint(ufID), uint(rID), user.ID)
	if err != nil {
		return false, err
	}

	return true, nil
}

// CreateFolder is the resolver for the createFolder field.
func (r *mutationResolver) CreateFolder(ctx context.Context, input model.CreateFolderInput) (*models.Folder, error) {
	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthenticated: %w", err)
	}

	var parentID *uint
	if input.ParentID != nil {
		pid, err := strconv.ParseUint(*input.ParentID, 10, 32)
		if err != nil {
			return nil, fmt.Errorf("invalid parent folder ID: %w", err)
		}
		pidUint := uint(pid)
		parentID = &pidUint
	}

	return r.Resolver.FolderService.CreateFolder(user.ID, input.Name, parentID)
}

// RenameFolder is the resolver for the renameFolder field.
func (r *mutationResolver) RenameFolder(ctx context.Context, input model.RenameFolderInput) (bool, error) {
	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return false, fmt.Errorf("unauthenticated: %w", err)
	}

	folderID, err := strconv.ParseUint(input.ID, 10, 32)
	if err != nil {
		return false, fmt.Errorf("invalid folder ID: %w", err)
	}

	err = r.Resolver.FolderService.RenameFolder(user.ID, uint(folderID), input.Name)
	if err != nil {
		return false, err
	}

	return true, nil
}

// DeleteFolder is the resolver for the deleteFolder field.
func (r *mutationResolver) DeleteFolder(ctx context.Context, id string) (bool, error) {
	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return false, fmt.Errorf("unauthenticated: %w", err)
	}

	folderID, err := strconv.ParseUint(id, 10, 32)
	if err != nil {
		return false, fmt.Errorf("invalid folder ID: %w", err)
	}

	err = r.Resolver.FolderService.DeleteFolder(user.ID, uint(folderID))
	if err != nil {
		return false, err
	}

	return true, nil
}

// MoveFolder is the resolver for the moveFolder field.
func (r *mutationResolver) MoveFolder(ctx context.Context, input model.MoveFolderInput) (bool, error) {
	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return false, fmt.Errorf("unauthenticated: %w", err)
	}

	folderID, err := strconv.ParseUint(input.ID, 10, 32)
	if err != nil {
		return false, fmt.Errorf("invalid folder ID: %w", err)
	}

	var parentID *uint
	if input.ParentID != nil {
		pid, err := strconv.ParseUint(*input.ParentID, 10, 32)
		if err != nil {
			return false, fmt.Errorf("invalid parent folder ID: %w", err)
		}
		pidUint := uint(pid)
		parentID = &pidUint
	}

	err = r.Resolver.FolderService.MoveFolder(user.ID, uint(folderID), parentID)
	if err != nil {
		return false, err
	}

	return true, nil
}

// MoveFile is the resolver for the moveFile field.
func (r *mutationResolver) MoveFile(ctx context.Context, input model.MoveFileInput) (bool, error) {
	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return false, fmt.Errorf("unauthenticated: %w", err)
	}

	fileID, err := strconv.ParseUint(input.ID, 10, 32)
	if err != nil {
		return false, fmt.Errorf("invalid file ID: %w", err)
	}

	var folderID *uint
	if input.FolderID != nil {
		fid, err := strconv.ParseUint(*input.FolderID, 10, 32)
		if err != nil {
			return false, fmt.Errorf("invalid folder ID: %w", err)
		}
		fidUint := uint(fid)
		folderID = &fidUint
	}

	err = r.Resolver.FolderService.MoveFile(user.ID, uint(fileID), folderID)
	if err != nil {
		return false, err
	}

	return true, nil
}

// ShareFolderToRoom is the resolver for the shareFolderToRoom field.
func (r *mutationResolver) ShareFolderToRoom(ctx context.Context, input model.ShareFolderToRoomInput) (bool, error) {
	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return false, fmt.Errorf("unauthenticated: %w", err)
	}

	folderID, err := strconv.ParseUint(input.FolderID, 10, 32)
	if err != nil {
		return false, fmt.Errorf("invalid folder ID: %w", err)
	}

	roomID, err := strconv.ParseUint(input.RoomID, 10, 32)
	if err != nil {
		return false, fmt.Errorf("invalid room ID: %w", err)
	}

	err = r.Resolver.FolderService.ShareFolderToRoom(user.ID, uint(folderID), uint(roomID))
	if err != nil {
		return false, err
	}

	return true, nil
}

// RemoveFolderFromRoom is the resolver for the removeFolderFromRoom field.
func (r *mutationResolver) RemoveFolderFromRoom(ctx context.Context, folderID string, roomID string) (bool, error) {
	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return false, fmt.Errorf("unauthenticated: %w", err)
	}

	fID, err := strconv.ParseUint(folderID, 10, 32)
	if err != nil {
		return false, fmt.Errorf("invalid folder ID: %w", err)
	}

	rID, err := strconv.ParseUint(roomID, 10, 32)
	if err != nil {
		return false, fmt.Errorf("invalid room ID: %w", err)
	}

	err = r.Resolver.FolderService.RemoveFolderFromRoom(user.ID, uint(fID), uint(rID))
	if err != nil {
		return false, err
	}

	return true, nil
}

// PromoteUserToAdmin is the resolver for the promoteUserToAdmin field.
func (r *mutationResolver) PromoteUserToAdmin(ctx context.Context, userID string) (bool, error) {
	_, err := middleware.RequireAdmin(ctx)
	if err != nil {
		return false, fmt.Errorf("admin access required: %w", err)
	}

	uID, err := strconv.ParseUint(userID, 10, 32)
	if err != nil {
		return false, fmt.Errorf("invalid user ID: %w", err)
	}

	err = r.Resolver.UserService.PromoteToAdmin(uint(uID))
	if err != nil {
		return false, err
	}

	return true, nil
}

// DeleteUserAccount is the resolver for the deleteUserAccount field.
func (r *mutationResolver) DeleteUserAccount(ctx context.Context, userID string) (bool, error) {
	_, err := middleware.RequireAdmin(ctx)
	if err != nil {
		return false, fmt.Errorf("admin access required: %w", err)
	}

	uID, err := strconv.ParseUint(userID, 10, 32)
	if err != nil {
		return false, fmt.Errorf("invalid user ID: %w", err)
	}

	err = r.Resolver.UserService.DeleteUser(uint(uID))
	if err != nil {
		return false, err
	}

	return true, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*models.User, error) {
	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthenticated: %w", err)
	}
	return user, nil
}

// MyFiles is the resolver for the myFiles field.
func (r *queryResolver) MyFiles(ctx context.Context, filter *model.FileFilterInput) ([]*models.UserFile, error) {
	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthenticated: %w", err)
	}

	var fileFilter *services.FileFilter
	if filter != nil {
		fileFilter = &services.FileFilter{
			Filename: filter.Filename,
			MimeType: filter.MimeType,
		}
		if filter.MinSize != nil {
			minSize := int64(*filter.MinSize)
			fileFilter.MinSize = &minSize
		}
		if filter.MaxSize != nil {
			maxSize := int64(*filter.MaxSize)
			fileFilter.MaxSize = &maxSize
		}
		if filter.DateFrom != nil {
			dateFrom := interface{}(*filter.DateFrom)
			fileFilter.DateFrom = &dateFrom
		}
		if filter.DateTo != nil {
			dateTo := interface{}(*filter.DateTo)
			fileFilter.DateTo = &dateTo
		}
		if filter.FolderID != nil {
			fileFilter.FolderID = filter.FolderID
		}
		// TODO: Add IncludeTrashed handling after gqlgen regeneration
		// if filter.IncludeTrashed != nil {
		// 	includeTrashed := *filter.IncludeTrashed
		// 	fileFilter.IncludeTrashed = &includeTrashed
		// }
	}

	return r.Resolver.StorageService.GetUserFiles(user.ID, fileFilter)
}

// MyTrashedFiles is the resolver for the myTrashedFiles field.
func (r *queryResolver) MyTrashedFiles(ctx context.Context) ([]*models.UserFile, error) {
	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthenticated: %w", err)
	}

	log.Printf("!!!!! MyTrashedFiles resolver called !!!!!")
	log.Printf("DEBUG: MyTrashedFiles called for user %d", user.ID)
	includeTrashed := true
	filter := &services.FileFilter{
		IncludeTrashed: &includeTrashed,
	}
	log.Printf("DEBUG: Calling StorageService.GetUserFiles with IncludeTrashed: %v", *filter.IncludeTrashed)
	return r.Resolver.StorageService.GetUserFiles(user.ID, filter)
}

// MyStats is the resolver for the myStats field.
func (r *queryResolver) MyStats(ctx context.Context) (*model.UserStats, error) {
	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthenticated: %w", err)
	}

	stats, err := r.Resolver.UserService.GetUserStats(user.ID)
	if err != nil {
		return nil, err
	}

	return &model.UserStats{
		TotalFiles:     stats.TotalFiles,
		UsedStorage:    stats.UsedStorage,
		StorageQuota:   stats.StorageQuota,
		StorageSavings: stats.StorageSavings,
	}, nil
}

// MyRooms is the resolver for the myRooms field.
func (r *queryResolver) MyRooms(ctx context.Context) ([]*models.Room, error) {
	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthenticated: %w", err)
	}

	return r.Resolver.RoomService.GetUserRooms(user.ID)
}

// Room is the resolver for the room field.
func (r *queryResolver) Room(ctx context.Context, id string) (*models.Room, error) {
	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthenticated: %w", err)
	}

	roomID, err := strconv.ParseUint(id, 10, 32)
	if err != nil {
		return nil, fmt.Errorf("invalid room ID: %w", err)
	}

	return r.Resolver.RoomService.GetRoom(uint(roomID), user.ID)
}

// MyFolders is the resolver for the myFolders field.
func (r *queryResolver) MyFolders(ctx context.Context) ([]*models.Folder, error) {
	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthenticated: %w", err)
	}

	return r.Resolver.FolderService.GetUserFolders(user.ID)
}

// Folder is the resolver for the folder field.
func (r *queryResolver) Folder(ctx context.Context, id string) (*models.Folder, error) {
	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthenticated: %w", err)
	}

	folderID, err := strconv.ParseUint(id, 10, 32)
	if err != nil {
		return nil, fmt.Errorf("invalid folder ID: %w", err)
	}

	return r.Resolver.FolderService.GetFolder(user.ID, uint(folderID))
}

// AdminDashboard is the resolver for the adminDashboard field.
func (r *queryResolver) AdminDashboard(ctx context.Context) (*model.AdminDashboard, error) {
	_, err := middleware.RequireAdmin(ctx)
	if err != nil {
		return nil, fmt.Errorf("admin access required: %w", err)
	}

	dashboard, err := r.Resolver.AdminService.GetDashboardStats()
	if err != nil {
		return nil, err
	}

	return &model.AdminDashboard{
		TotalUsers:       dashboard.TotalUsers,
		TotalFiles:       dashboard.TotalFiles,
		TotalStorageUsed: dashboard.TotalStorageUsed,
		RecentUploads:    dashboard.RecentUploads,
	}, nil
}

// AllUsers is the resolver for the allUsers field.
func (r *queryResolver) AllUsers(ctx context.Context) ([]*models.User, error) {
	_, err := middleware.RequireAdmin(ctx)
	if err != nil {
		return nil, fmt.Errorf("admin access required: %w", err)
	}

	return r.Resolver.UserService.GetAllUsers()
}

// AllFiles is the resolver for the allFiles field.
func (r *queryResolver) AllFiles(ctx context.Context) ([]*models.UserFile, error) {
	_, err := middleware.RequireAdmin(ctx)
	if err != nil {
		return nil, fmt.Errorf("admin access required: %w", err)
	}

	return r.Resolver.StorageService.GetAllFiles()
}

// Health is the resolver for the health field.
func (r *queryResolver) Health(ctx context.Context) (string, error) {
	return "OK", nil
}

// ID is the resolver for the id field.
func (r *roomResolver) ID(ctx context.Context, obj *models.Room) (string, error) {
	return fmt.Sprintf("%d", obj.ID), nil
}

// CreatorID is the resolver for the creator_id field.
func (r *roomResolver) CreatorID(ctx context.Context, obj *models.Room) (string, error) {
	return fmt.Sprintf("%d", obj.CreatorID), nil
}

// Folders is the resolver for the folders field.
func (r *roomResolver) Folders(ctx context.Context, obj *models.Room) ([]*models.Folder, error) {
	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthenticated: %w", err)
	}

	// Verify user has access to this room
	var roomMember models.RoomMember
	db := database.GetDB()
	if err := db.Where("room_id = ? AND user_id = ?", obj.ID, user.ID).First(&roomMember).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, fmt.Errorf("access denied: not a member of this room")
		}
		return nil, fmt.Errorf("database error: %w", err)
	}

	// Get folders shared to this room
	var roomFolders []*models.RoomFolder
	if err := db.Where("room_id = ?", obj.ID).Preload("Folder", "deleted_at IS NULL").Find(&roomFolders).Error; err != nil {
		return nil, fmt.Errorf("database error: %w", err)
	}

	var folders []*models.Folder
	for _, rf := range roomFolders {
		if rf.Folder.DeletedAt.Valid == false { // Only include non-deleted folders
			folders = append(folders, &rf.Folder)
		}
	}

	return folders, nil
}

// ID is the resolver for the id field.
func (r *roomMemberResolver) ID(ctx context.Context, obj *models.RoomMember) (string, error) {
	return fmt.Sprintf("%d", obj.ID), nil
}

// RoomID is the resolver for the room_id field.
func (r *roomMemberResolver) RoomID(ctx context.Context, obj *models.RoomMember) (string, error) {
	return fmt.Sprintf("%d", obj.RoomID), nil
}

// UserID is the resolver for the user_id field.
func (r *roomMemberResolver) UserID(ctx context.Context, obj *models.RoomMember) (string, error) {
	return fmt.Sprintf("%d", obj.UserID), nil
}

// ID is the resolver for the id field.
func (r *userResolver) ID(ctx context.Context, obj *models.User) (string, error) {
	return fmt.Sprintf("%d", obj.ID), nil
}

// ID is the resolver for the id field.
func (r *userFileResolver) ID(ctx context.Context, obj *models.UserFile) (string, error) {
	return fmt.Sprintf("%d", obj.ID), nil
}

// UserID is the resolver for the user_id field.
func (r *userFileResolver) UserID(ctx context.Context, obj *models.UserFile) (string, error) {
	return fmt.Sprintf("%d", obj.UserID), nil
}

// FileID is the resolver for the file_id field.
func (r *userFileResolver) FileID(ctx context.Context, obj *models.UserFile) (string, error) {
	return fmt.Sprintf("%d", obj.FileID), nil
}

// EncryptionKey is the resolver for the encryption_key field.
func (r *userFileResolver) EncryptionKey(ctx context.Context, obj *models.UserFile) (string, error) {
	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return "", fmt.Errorf("unauthenticated: %w", err)
	}

	// Ensure the user owns this file
	if user.ID != obj.UserID {
		return "", fmt.Errorf("access denied: file does not belong to user")
	}

	return obj.EncryptionKey, nil
}

// FolderID is the resolver for the folder_id field.
func (r *userFileResolver) FolderID(ctx context.Context, obj *models.UserFile) (*string, error) {
	if obj.FolderID == nil {
		return nil, nil
	}
	folderID := fmt.Sprintf("%d", *obj.FolderID)
	return &folderID, nil
}

// File returns generated.FileResolver implementation.
func (r *Resolver) File() generated.FileResolver { return &fileResolver{r} }

// Folder returns generated.FolderResolver implementation.
func (r *Resolver) Folder() generated.FolderResolver { return &folderResolver{r} }

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

// Room returns generated.RoomResolver implementation.
func (r *Resolver) Room() generated.RoomResolver { return &roomResolver{r} }

// RoomMember returns generated.RoomMemberResolver implementation.
func (r *Resolver) RoomMember() generated.RoomMemberResolver { return &roomMemberResolver{r} }

// User returns generated.UserResolver implementation.
func (r *Resolver) User() generated.UserResolver { return &userResolver{r} }

// UserFile returns generated.UserFileResolver implementation.
func (r *Resolver) UserFile() generated.UserFileResolver { return &userFileResolver{r} }

type fileResolver struct{ *Resolver }
type folderResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type roomResolver struct{ *Resolver }
type roomMemberResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
type userFileResolver struct{ *Resolver }
